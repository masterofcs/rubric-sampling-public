r"""Programs are generated by a three step process

1. Randomly expand a PCFG
2. Apply a post function (which does the nesting transform)
3. Generate a trajectory of code to get to that point

Theta provides the weights for the different production rules
of the CFG. Specifically, they are unnormalized conditional
probabilities. The last value of theta is the probability that
the student didn't get nesting.

***** SIMULATE SPARSE ******
This script does not generate the series of steps that a student
takes to get to their intended goal. We found in practice that 
the naive way to unroll intermediate problems that did not work.
"""

from __future__ import division
from __future__ import print_function
from __future__ import absolute_import

import re
import os
import sys
import random
import numpy as np
from tqdm import tqdm

from pcfg_utils.models import blockyToTree
from pcfg_utils.models import blocky
from utils import flatten_ast

# constants
DEFAULT_P_DNG_NESTING = 0.1
SWITCH_DELIM = '=====\n'
MAX_DEPTH = 50

# eek I have a global, but I am very careful with its use
prodIndex = 0

# this is the public method you should call!
def generateTrajectories(theta, nTrajectories, cfg_path):
    global prodIndex
    prodIndex = 0
    countMap = {}
    labelMap = {}
    cfg = loadCfg(theta, cfg_path)
    
    if theta is not None:
        # the plus one is for the p(d.n.g. nesting)
        expectedSize = prodIndex + 1

        if len(theta) != expectedSize:
            raise Exception('Theta is the wrong size. Expected ' + str(expectedSize))

    pbar = tqdm(total=nTrajectories)

    count = 0
    while count < nTrajectories:
        # generate a goal!
        tags, code = expandCfg(cfg, 'Program', 0)
        functionTags, code = applyPostFunctions(theta, code)
        decisions = getDecisions(tags, functionTags)
        goal = blockyToTree.convert(code)

        # register the generated code
        if blocky.isValid(goal):
            goal = ' '.join(flatten_ast(goal))
            countTree(countMap, labelMap, decisions, goal)

        pbar.update()
        # increment this up as generating a valid program
        count += 1

    pbar.close()

    return countMap, labelMap


def generateStringPrograms(theta, nTrajectories, cfg_path):
    cfg = loadCfg(theta, cfg_path)
    programs = []
    for i in xrange(nTrajectories):
        tags, code = expandCfg(cfg, 'Program', 0)
        programs.append(code)
    return programs


def getDecisions(tags, fnTags):
    allDecisions = set(fnTags)
    for key in tags:
        for d in tags[key]:
            allDecisions.add(d)
    return allDecisions


def loadCfg(theta, cfg_path):
    cfgText = open(cfg_path).read()
    tokens = {}
    rawTokens = cfgText.split('<')
    for rawToken in rawTokens:
        inner = rawToken.split('/>')[0]
        parts = inner.split(SWITCH_DELIM)
        name = parts[0].strip() # first part is the name
        productions = []
        for part in parts[1:]:
            productions.append(parseProduction(theta, part))
        token = productions
        reweightProbabilities(token)
        tokens[name] = token
    return tokens


def reweightProbabilities(tokens):
    total = 0.0
    for production in tokens:
        total += production['weight']
    for production in tokens:
        newWeight = production['weight'] / total
        production['p'] = newWeight


def parseProduction(theta, part):
    global prodIndex
    tags = []
    text = ''
    weight = 100.0
    fixedWeight = False
    for line in part.split('\n'):
        if len(line) == 0:
            continue
        if line[0] == "*":
            weightLine = line[1:].strip()
            if weightLine[-1] == '!':
                fixedWeight = True
                weight = float(weightLine[:-1].strip())
            else:
                weight = float(weightLine)
        elif line[0] == '#':
            tag = line[1:].strip()
            tags.append(tag)
        else:
            text += line
    # use the theta vector if it was provided
    if(theta is not None and not fixedWeight):
        weight = theta[prodIndex]
    if not fixedWeight:
        prodIndex += 1
    return {
        'tags':tags,
        'text':text,
        'weight':weight
    }


def expandCfg(cfg, name, depth):
    # base case, depth > MAX_DEPTH
    if depth > MAX_DEPTH: return [], ''

    options = cfg[name]

    # chose a production based on its conditional probability
    probabilities = []
    for option in options:
        probabilities += [option['p']]
    production = np.random.choice(options, 1, p=probabilities)[0]
    
    # expand the production
    #print production
    prodStr = production['text']
    tagsA = {name: production['tags']}
    tagsB, code = expandText(cfg, prodStr, depth)
    tagsB.update(tagsA) # original productions get higher precidence
    return tagsB, code


def expandText(cfg, prodStr, depth):
    prodStr = expandRandInt(prodStr)
    prodStr = prodStr.replace('\\n', '\n')
    if '{{' in prodStr:
        parensStart = prodStr.index('{{')
        nextTokenStart = parensStart + 2
        nextTokenEnd = prodStr.index('}}')
        parensEnd = nextTokenEnd + 2
        tokenName = prodStr[nextTokenStart:nextTokenEnd]

        tagsA, tokenStr = expandCfg(cfg, tokenName, depth+1)

        reducedStr = prodStr[:parensStart] + tokenStr + prodStr[parensEnd:]
        tagsB, code = expandText(cfg, reducedStr, depth)
        tagsB.update(tagsA)
        return tagsB, code
    else:
        return {}, prodStr


# assumes that each production has at most one randInt
def expandRandInt(prodStr):
    key = 'randInt'
    if key in prodStr:
        randStart = prodStr.index(key)
        paramsStart = randStart + len(key) + 1
        paramsEnd = prodStr.index(')', paramsStart) 
        paramsStr = prodStr[paramsStart:paramsEnd]
        if(paramsStr == ''):
            return unboundedRandomInt()
        else:
            parts = paramsStr.split(',')
            lower = int(parts[0].strip())
            upper = int(parts[1].strip())
            return str(random.randint(lower, upper))
    else:
        return prodStr


def unboundedRandomInt():
    number = ''
    number += str(random.randint(1, 9))
    while random.random() > 0.4:
        number += str(random.randint(0, 9))
    return number


def countTree(countMap, labelMap, decisions, ast):
    decisionStr = getDecisionStr(decisions)
    if not ast in countMap:
        countMap[ast] = 0
    countMap[ast] += 1
    if not ast in labelMap:
        labelMap[ast] = {}
    if not decisionStr in labelMap[ast]:
        labelMap[ast][decisionStr] = 0
    labelMap[ast][decisionStr] += 1


def getDecisionStr(decisions):
    decisionList = list(decisions)
    decisionList.sort()
    decisionStr = ''
    for d in decisionList:
        decisionStr += d + '\n'
    return decisionStr


def applyPostFunctions(theta, code):
    p = DEFAULT_P_DNG_NESTING
    if theta is not None:
        # recall that the last value of theta is reserved
        # for this function
        p = theta[-1]

    # apply the don't get nesting function
    if 'Repeat' in code:
        if random.random() < p:
            repeatStart = code.index('Repeat')
            blockStart = code.index('{', repeatStart) + 1
            blockEnd = code.index('}', repeatStart)
            body = code[blockStart:blockEnd].strip()
            
            # punt on bodies with nesting loops
            if '{' in body:
                return [], code
            lines = body.split('\n')
            # punt if num lines is less that or equal to 2
            if len(lines) < 2:
                return [], code

            # put only the first line in the repeat
            newBlock = lines[0]+'\n'
            newBlock += '}\n'
            for line in lines[1:]:
                newBlock += line + '\n'

            beforeBlock = code[:blockStart]
            afterBlock = code[blockEnd+1:]
            
            newCode = beforeBlock + '\n' + newBlock + '\n' + afterBlock
            return ['Does not get nesting'], newCode

    return [], code


def reset_prodIndex():
    global prodIndex
    prodIndex = 0
